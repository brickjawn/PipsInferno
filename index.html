<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quack out of Heck: Pip's Inferno</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2a045c"/>
    <link rel="apple-touch-icon" href="./pip_icon_192.png">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { display: flex; justify-content: center; align-items: center; min-height: 100vh; background: linear-gradient(to bottom, #0a134e, #2a045c); font-family: 'Press Start 2P', cursive, Arial, sans-serif; overflow: hidden; touch-action: none; }
        #gameContainer { position: relative; width: 800px; height: 500px; overflow: hidden; background: #000; border-radius: 10px; box-shadow: 0 0 30px rgba(120, 0, 120, 0.7); z-index: 10; }
        canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        #uiContainer { position: absolute; top: 10px; left: 10px; z-index: 25; color: white; text-shadow: 2px 2px 0 #000; font-size: 14px; display: flex; align-items: center; gap: 15px; background-color: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 5px;}
        #gameMessages { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 30; background: rgba(0,0,0,0.9); color: #f0f; padding: 30px 45px; border-radius: 15px; text-align: center; font-size: 26px; border: 4px solid #80f; box-shadow: 0 0 25px rgba(255,0,255,0.6); display: none; max-width: 85%; }
        #mobileControls { position: absolute; bottom: 15px; left: 0; right: 0; justify-content: space-between; padding: 0 15px; z-index: 20; display: none; }
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        .dpad { display: grid; grid-template-columns: repeat(3, 55px); grid-template-rows: repeat(3, 55px); gap: 4px; }
        .dpad div { background: rgba(200,200,255,0.6); border-radius: 8px; cursor: pointer; display: flex; justify-content: center; align-items: center; color: #0a134e; font-weight: bold; font-size: 18px; user-select: none; box-shadow: 0 4px 8px rgba(0,0,0,0.4); }
        .action-button { width: 75px; height: 75px; background: rgba(255,80,80,0.6); border-radius: 37px; display: flex; justify-content: center; align-items: center; cursor: pointer; color: white; font-weight: bold; font-size: 18px; box-shadow: 0 4px 8px rgba(0,0,0,0.4); user-select: none; border: 2px solid #fff; }
        .large-btn { min-width: 200px; height: 55px; background: linear-gradient(to bottom, #7F00FF, #4A00E0); color: white; border: none; border-radius: 30px; font-size: 20px; font-weight: bold; font-family: 'Press Start 2P', cursive; cursor: pointer; margin-top: 25px; box-shadow: 0 6px 20px rgba(0,0,0,0.4); padding: 0 20px; }
        .large-btn:hover { background: linear-gradient(to bottom, #9D4EDD, #5A189A); transform: translateY(-2px); }
        #bossHealthBarContainer { position: absolute; top: 10px; right: 10px; width: 200px; height: 20px; background-color: #555; border-radius: 5px; z-index: 25; display: none; border: 2px solid #000;}
        #bossHealthBar { width: 100%; height: 100%; background-color: #ff0000; border-radius: 3px; transition: width 0.3s ease-out; }
        .ui-button {
            background-color: rgba(255,255,255,0.2);
            border: 1px solid white;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            text-shadow: 1px 1px 0 #000;
        }
        .ui-button:hover {
            background-color: rgba(255,255,255,0.4);
        }

        @media (max-width: 820px) {
            #gameContainer { width: 100%; height: 100vh; max-height: 100dvh; border-radius: 0; }
            #mobileControls { display: flex; }
            #uiContainer {font-size: 12px;}
            .ui-button {font-size: 8px; padding: 3px 6px;}
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
</head>
<body>
    <div id="gameContainer">
        <div id="uiContainer">
            <div id="scoreDisplay">Crumbs: <span id="score">0</span></div>
            <div id="livesDisplay">Lives: <span id="lives">3</span></div>
            <div id="levelDisplay">Level: <span id="level">1/10</span></div>
            <button id="muteButton" class="ui-button">Mute üîä</button>
        </div>
        <div id="bossHealthBarContainer">
            <div id="bossHealthBar"></div>
        </div>
        <div id="gameMessages">
            <p id="messageText">Get Ready!</p>
            <button id="restartButton" class="large-btn">Play Again</button>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="mobileControls">
            <div class="control-group"> <div class="dpad"> <div></div> <div id="up" class="dir-btn">‚Üë</div> <div></div> <div id="left" class="dir-btn">‚Üê</div> <div></div> <div id="right" class="dir-btn">‚Üí</div> <div></div> <div id="down" class="dir-btn">‚Üì</div> <div></div> </div> </div>
            <div class="control-group"> <div id="jumpBtn" class="action-button">JUMP</div> </div>
        </div>
    </div>

    <script>
        // Game Constants
        const GRAVITY = 0.75;
        const PLAYER_JUMP_FORCE = -17; 
        const PLAYER_ACCEL = 0.25;
        const PLAYER_DECEL = 0.35;
        const MAX_SPEED = 10; 
        const PLAYER_INVULNERABILITY_DURATION = 90; 
        
        const STATE_SPLASH = 0; 
        const STATE_PLAYING = 1;
        const STATE_GAMEOVER = 2;
        const STATE_WON = 3;
        const STATE_PAUSED = 4; 
        
        const COLORS = {
            SKY: ["#1c0b2c", "#2d1147", "#0a041a"], 
            FAR_MOUNTAINS: "#1f1033", NEAR_MOUNTAINS: "#2a1642",
            PLATFORM: "#5c3b1e", COLLECTIBLE: "#FFD700", 
            ENEMY_NORMAL: "#D32F2F", ENEMY_HOPPER: "#388E3C", ENEMY_DASHER: "#F57C00", 
            PLAYER_DEFAULT: "#FFFF00", // Default yellow
            FINISH_LINE: "#7B1FA2", 
            BOSS_BODY: "#2E8B57", BOSS_SNOUT: "#20603D", BOSS_HIT: "#FF6347", 
            FIRE_PIT_PRIMARY: "rgba(255, 69, 0, 0.7)", 
            FIRE_PIT_SECONDARY: "rgba(255, 140, 0, 0.6)", 
            ICE_PIT_PRIMARY: "rgba(173, 216, 230, 0.7)", 
            ICE_PIT_SECONDARY: "rgba(135, 206, 250, 0.6)", 
        };

        const DUCK_PROGRESSION_COLORS = [
            "#FFFF00", // Level 0 (Limbo) - Original Yellow
            "#FFEE00", // Level 1 (Lust) - Slightly Oranger Yellow
            "#FFD700", // Level 2 (Gluttony) - Gold
            "#FFA500", // Level 3 (Greed) - Orange
            "#FF8C00", // Level 4 (Wrath) - Dark Orange
            "#FF7000", // Level 5 (Heresy) - Orange-Red
            "#FF4500", // Level 6 (Violence) - OrangeRed
            "#FF0000", // Level 7 (Fraud) - Red
            "#DC143C", // Level 8 (Treachery) - Crimson
            "#B22222"  // Level 9 (Kaiman's Lair) - Firebrick Red
        ];
        
        let canvas, ctx;
        let gameState = STATE_SPLASH;
        let currentLevel = 0; // 0-indexed
        let player, platforms = [], enemies = [], collectibles = [];
        let kaimanBoss = null; 
        let cameraOffset = 0;
        let lives = 3; 
        let breadcrumbsCollected = 0; 
        let bgOffsetX = 0, bgOffsetX2 = 0; 
        let animationFrame;
        let playerVelocity = {x: 0, y: 0};
        let isJumping = false;
        let playerInputs = { left: false, right: false };
        let finishLine = 0; 
        const TOTAL_LEVELS = 10; // 9 Circles + Boss Lair
        let fireParticles = [];

        // --- Tone.js Sound Setup ---
        let enemyDefeatNoise, enemyDefeatImpact, currentMusicLoop,
            victorySound, hurtQuackSound, dyingQuackSound, dyingQuackPitchEnv,
            crumbCollectSound; 
        let musicInitialized = false;
        let isMuted = false; // Mute state
        let levelMusicTracks = []; 
        const SAFE_AUDIO_OFFSET = 0.05; // Increased offset for safety

        function initializeAudio() {
            if (musicInitialized) return;
            
            enemyDefeatNoise = new Tone.NoiseSynth({
                noise: { type: "pink" }, 
                envelope: { attack: 0.001, decay: 0.12, sustain: 0, release: 0.12, attackCurve: "linear", decayCurve: "linear", releaseCurve: "linear" }, 
                volume: -3 
            }).toDestination();

            enemyDefeatImpact = new Tone.MembraneSynth({ 
                pitchDecay: 0.07, octaves: 1.5, 
                envelope: { attack: 0.001, decay: 0.25, sustain: 0, release: 0.25, attackCurve: "linear", decayCurve: "linear", releaseCurve: "linear" },
                volume: 0 
            }).toDestination();

            victorySound = new Tone.PolySynth(Tone.Synth, {
                oscillator: {type: "triangle8"},
                envelope: {attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.5, attackCurve: "linear", decayCurve: "linear", releaseCurve: "linear"},
                volume: -8
            }).toDestination();
            
            hurtQuackSound = new Tone.Synth({
                oscillator: {type: "square"},
                envelope: {attack:0.005, decay:0.05, sustain:0, release:0.1, attackCurve: "linear", decayCurve: "linear", releaseCurve: "linear"},
                volume: -5
            }).toDestination();

            dyingQuackSound = new Tone.Synth({
                oscillator: {type: "sawtooth"},
                envelope: {attack:0.01, decay:0.3, sustain:0.1, release:0.8, attackCurve: "linear", decayCurve: "linear", releaseCurve: "linear"}, 
                volume: -5
            }).toDestination();
            dyingQuackPitchEnv = new Tone.FrequencyEnvelope({
                attack: 0.01, 
                decay: 0.7,   
                sustain: 0,   
                release: 0.1, 
                attackCurve: "linear", 
                decayCurve: "linear",  
                releaseCurve: "linear", 
                baseFrequency: "C4", 
                octaves: -1.5     
            }).connect(dyingQuackSound.frequency); 

            crumbCollectSound = new Tone.PolySynth(Tone.Synth, { 
                polyphony: 4, 
                volume: -15,
                oscillator: { type: "triangle" },
                envelope: { attack: 0.002, decay: 0.08, sustain: 0, release: 0.1, attackCurve: "linear", decayCurve: "linear", releaseCurve: "linear" }
            }).toDestination();


            // --- Define Music For Each Level ---
            levelMusicTracks[0] = () => { // Limbo
                const synth = new Tone.PolySynth(Tone.AMSynth, { volume: -20 }).toDestination();
                const notes = ["A2", "C3", "E3", "G2"];
                return new Tone.Loop(time => synth.triggerAttackRelease(notes[Math.floor(Math.random()*notes.length)], "2n", time), "1m").set({humanize: "8n"});
            };
            levelMusicTracks[1] = () => { // Lust 
                const synth = new Tone.FMSynth({ harmonicity: 1.2, modulationIndex: 5, detune:0, oscillator:{type:"sine"}, envelope:{attack:0.01,decay:0.2,sustain:0.01,release:0.5}, modulation:{type:"square"}, modulationEnvelope:{attack:0.01,decay:0.1,sustain:0.01,release:0.5}, volume: -18}).toDestination();
                const lustNotes = ["C4", "Eb4", "G4", "Bb4", "G4", "Eb4"]; 
                const lustSequence = new Tone.Sequence((time, note) => {
                    synth.triggerAttackRelease(note, "8n", time);
                }, lustNotes, "8n");
                lustSequence.loop = true; 
                return lustSequence; 
            };
            levelMusicTracks[2] = () => { // Gluttony
                const synth = new Tone.MonoSynth({ oscillator:{type:"pwm", modulationFrequency:0.5}, envelope:{attack:0.1,decay:0.3,sustain:0.2,release:0.8}, filterEnvelope:{attack:0.1,decay:0.2,sustain:0.1,release:1,baseFrequency:80,octaves:1.5}, volume:-15}).toDestination();
                const notes = ["F2", "D2", "C2"];
                return new Tone.Loop(time => synth.triggerAttackRelease(notes[Math.floor(Math.random()*notes.length)], "1n", time), "1m");
            };
             levelMusicTracks[3] = () => { // Greed
                const metalSynth = new Tone.MetalSynth({frequency: 100, envelope:{attack:0.001, decay:0.2, release:0.1}, harmonicity:3.1, modulationIndex:16, octaves:0.5, volume:-22}).toDestination();
                const noise = new Tone.NoiseSynth({noise:{type:"pink"}, envelope:{attack:0.01,decay:0.05,sustain:0}, volume:-25}).toDestination();
                return new Tone.Loop(time => {
                    metalSynth.triggerAttackRelease("16n", time, Math.random()*0.5 + 0.5);
                    if(Math.random() < 0.3) noise.triggerAttackRelease("32n", time);
                }, "8n");
            };
            levelMusicTracks[4] = () => { // Wrath
                const synth = new Tone.NoiseSynth({noise:{type:"brown"}, envelope:{attack:0.005,decay:0.1,sustain:0}, volume:-15}).toDestination();
                const kick = new Tone.MembraneSynth({pitchDecay:0.05,octaves:5,envelope:{attack:0.001,decay:0.2,sustain:0}, volume:-10}).toDestination();
                return new Tone.Loop(time => {
                    kick.triggerAttackRelease("C1", "8n", time);
                    if(Math.random() < 0.6) synth.triggerAttackRelease("16n", time + Tone.Time("16n").toSeconds());
                }, "4n");
            };
            levelMusicTracks[5] = () => { // Heresy 
                const leadSynth = new Tone.FMSynth({
                    harmonicity: 1.8,
                    modulationIndex: 6,
                    oscillator: { type: "fmsquare", modulationType:"sine" },
                    envelope: { attack: 0.02, decay: 0.4, sustain: 0.1, release: 0.8 },
                    volume: -16
                }).toDestination();
                const bassSynth = new Tone.MonoSynth({
                    oscillator: { type: "pulse", width: 0.6 },
                    filter: { Q: 1, type: "lowpass", rolloff: -12 },
                    envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 1 },
                    filterEnvelope: { attack: 0.1, decay: 0.2, sustain: 0.1, baseFrequency: 60, octaves: 2.5 },
                    volume: -14
                }).toDestination();
                const reverb = new Tone.Reverb(2.0).toDestination();
                leadSynth.connect(reverb); bassSynth.connect(reverb);

                const leadMelody = new Tone.Sequence((time, note) => {
                    leadSynth.triggerAttackRelease(note, "2n", time);
                }, ["E3", "G3", "D3", "F#3", "C3", "E3", "B2", "D3"], "2n");
                leadMelody.loop = true;

                const bassLine = new Tone.Sequence((time, note) => {
                    bassSynth.triggerAttackRelease(note, "1m", time);
                }, ["A1", "F1", "C2", "G1"], "1m");
                bassLine.loop = true;
                
                leadMelody.start(0); bassLine.start(0);
                return new Tone.Loop(()=>{}, "1m"); 
            };
            levelMusicTracks[6] = () => { // Violence 
                const kick = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 3, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -6 }).toDestination();
                const snare = new Tone.NoiseSynth({ noise: { type: "white", playbackRate: 1.2 }, envelope: { attack: 0.001, decay: 0.06, sustain: 0 }, volume: -14 }).toDestination();
                const hihat = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.001, decay: 0.02, sustain: 0 }, volume: -22 }).toDestination();
                
                const melodySynth = new Tone.Synth({
                    oscillator: { type: "sawtooth6" }, 
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.02, release: 0.15 },
                    volume: -15
                }).toDestination();
                 const distortion = new Tone.Distortion(0.3).toDestination();
                 melodySynth.connect(distortion);

                const bassSynth = new Tone.MonoSynth({ oscillator: { type: "fmsquare", modulationType:"triangle", harmonicity:0.6 }, envelope: { attack: 0.01, decay: 0.08, sustain: 0.1, release: 0.15 }, volume: -10 }).toDestination();
                
                const melodyNotes = ["D3", "Eb3", "F3", "Eb3", "D3", "C3", "Bb2", "C3"];
                const bassLine = ["D2", "D2", "D2", "G1", "A#1", "A#1", "A#1", "G1"];
                let beatCount = 0;

                return new Tone.Loop(time => {
                    if (beatCount % 4 === 0) kick.triggerAttackRelease("C1", "8n", time);
                    if (beatCount % 8 === 4) snare.triggerAttackRelease("16n", time);
                    if (beatCount % 2 !== 0) hihat.triggerAttackRelease("32n", time, 0.5);
                    
                    if (beatCount % 2 === 0) { 
                        melodySynth.triggerAttackRelease(melodyNotes[ (beatCount/2) % melodyNotes.length], "16n", time);
                    }
                    if (beatCount % 4 === 0) { 
                         bassSynth.triggerAttackRelease(bassLine[ (beatCount/4) % bassLine.length], "4n", time);
                    }
                    beatCount++;
                }, "16n");
            };
            levelMusicTracks[7] = () => { // Fraud
                const synth = new Tone.AMSynth({harmonicity:1.5, envelope:{attack:0.02,decay:0.3,sustain:0.1,release:0.6}, volume:-19}).toDestination();
                const chorus = new Tone.Chorus(4, 2.5, 0.7).toDestination().start(); synth.connect(chorus);
                const notes = ["D#3", "F#3", "A3", "C4", "A3", "F#3"];
                return new Tone.Sequence((time, note) => synth.triggerAttackRelease(note, "8t", time), notes, "4n");
            };
            levelMusicTracks[8] = () => { // Treachery
                const synth = new Tone.Synth({oscillator:{type:"sine"}, envelope:{attack:0.5,decay:1,sustain:0.5,release:2}, volume:-15}).toDestination();
                const filter = new Tone.AutoFilter("2n").toDestination().start();
                const reverb = new Tone.Freeverb(0.9, 3000).toDestination();
                synth.chain(filter, reverb);
                const notes = ["C5", "B4", "A#4", "A4"]; 
                return new Tone.Loop(time => synth.triggerAttackRelease(notes[Math.floor(Math.random()*notes.length)], "1m", time), "1m");
            };
            levelMusicTracks[9] = () => { // Kaiman's Lair (Boss)
                const lead = new Tone.Synth({
                    oscillator:{type:"pwm", modulationFrequency:0.8},
                    envelope:{attack:0.01,decay:0.2,sustain:0.1,release:0.3},
                    volume:-30  // Reduced from -22
                }).toDestination();
                
                const bass = new Tone.MonoSynth({
                    oscillator:{type:"sawtooth"},
                    filter:{type:"lowpass", Q:2, rolloff:-24},
                    filterEnvelope:{attack:0.01,decay:0.1,sustain:0.2,release:0.5, baseFrequency:50, octaves:3},
                    volume:-28  // Reduced from -20
                }).toDestination();
                
                const drums = new Tone.NoiseSynth({
                    noise:{type:"white"},
                    envelope:{attack:0.001,decay:0.05,sustain:0},
                    volume:-35  // Reduced from -28
                }).toDestination();
                
                const leadPattern = new Tone.Sequence((time,note) => lead.triggerAttackRelease(note, "16n", time), ["G3", "Ab3", "G3", "F3", "Eb3", "D3", "C3"], "8n");
                const bassPattern = new Tone.Sequence((time,note) => bass.triggerAttackRelease(note, "4n", time), ["C2", "C2", "G1", "G1"], "4n");
                const drumPattern = new Tone.Loop(time => drums.triggerAttackRelease("32n", time), "16n");
                
                leadPattern.start(0); bassPattern.start(0); drumPattern.start(0);
                return new Tone.Loop(()=>{}, "1m"); 
            };

            // Start transport once after all synths are created
            if (Tone.Transport.state !== "started") {
                Tone.Transport.start();
            }
            musicInitialized = true;
        }

        function playEnemyDefeatSound() {
            if (enemyDefeatNoise && enemyDefeatImpact && Tone.context.state === 'running') {
                const now = Tone.now() + SAFE_AUDIO_OFFSET; 
                enemyDefeatNoise.triggerAttackRelease("8n", now); 
                enemyDefeatImpact.triggerAttackRelease("D1", "8n", now + 0.015); 
            }
        }
        function playVictorySound() {
            if (victorySound && Tone.context.state === 'running') {
                victorySound.triggerAttackRelease(["C4", "E4", "G4", "C5"], "4n", Tone.now() + SAFE_AUDIO_OFFSET);
            }
        }
        function playHurtQuack() {
             if (hurtQuackSound && Tone.context.state === 'running') {
                hurtQuackSound.triggerAttackRelease("A4", "16n", Tone.now() + SAFE_AUDIO_OFFSET);
            }
        }
        function playDyingQuack() {
            if (dyingQuackSound && dyingQuackPitchEnv && Tone.context.state === 'running') {
                const now = Tone.now() + SAFE_AUDIO_OFFSET; 
                
                dyingQuackSound.envelope.cancel(0); 
                dyingQuackPitchEnv.cancel(0);   
                dyingQuackSound.frequency.cancelScheduledValues(0); 

                dyingQuackSound.frequency.setValueAtTime("C4", now); 
                dyingQuackSound.envelope.triggerAttack(now); 
                dyingQuackPitchEnv.triggerAttack(now); 
                
                const soundDuration = dyingQuackSound.envelope.attack + dyingQuackSound.envelope.decay + dyingQuackSound.envelope.sustain;
                const pitchEnvDuration = dyingQuackPitchEnv.attack + dyingQuackPitchEnv.decay + dyingQuackPitchEnv.sustain;
                const longestDuration = Math.max(soundDuration, pitchEnvDuration);

                const releaseStart = now + longestDuration;
                
                dyingQuackSound.envelope.triggerRelease(releaseStart + dyingQuackSound.envelope.release);
                dyingQuackPitchEnv.triggerRelease(releaseStart + dyingQuackPitchEnv.release); 
            }
        }
        function playCrumbCollectSound() {
            if (crumbCollectSound && Tone.context.state === 'running') {
                crumbCollectSound.triggerAttackRelease("C6", "32n", Tone.now() + SAFE_AUDIO_OFFSET); 
            }
        }


        async function ensureAudioContextAndTransportStarted() {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }
            if (!musicInitialized) { 
                initializeAudio(); // This will also start Transport
            } else if (Tone.Transport.state !== "started") { // If initialized but transport somehow stopped
                Tone.Transport.start(Tone.now() + 0.1); 
            }
        }


        function startMusic(levelIndex = currentLevel) { 
            ensureAudioContextAndTransportStarted().then(() => {
                if (!musicInitialized || !levelMusicTracks[levelIndex]) {
                    console.warn(`Music track for level ${levelIndex} not found.`);
                    return;
                }
                
                stopMusic(); 

                currentMusicLoop = levelMusicTracks[levelIndex](); 
                if (currentMusicLoop && typeof currentMusicLoop.start === 'function') { 
                    if (levelIndex === TOTAL_LEVELS - 1) { 
                        Tone.Transport.bpm.value = 130;
                    } else if (levelIndex === 1) { 
                        Tone.Transport.bpm.value = 110;
                    } else if (levelIndex === 4) { 
                        Tone.Transport.bpm.value = 140;
                    } else if (levelIndex === 6) { 
                        Tone.Transport.bpm.value = 120;
                    } else if (levelIndex === 5) { 
                        Tone.Transport.bpm.value = 70; 
                    } else {
                        Tone.Transport.bpm.value = 75 + (levelIndex * 5); 
                    }
                    currentMusicLoop.start(0); 
                }
            });
        }

        function stopMusic() { // Stops only the current music loop, not the main transport
            if (musicInitialized && currentMusicLoop) {
                if (typeof currentMusicLoop.stop === 'function') {
                    currentMusicLoop.stop(0); 
                }
                if(typeof currentMusicLoop.dispose === 'function') {
                    currentMusicLoop.dispose();
                }
                // If the loop was a collection of patterns (like boss music), stop them individually
                if (currentLevel === TOTAL_LEVELS - 1) { // Boss level specific cleanup
                    const bossTrack = levelMusicTracks[TOTAL_LEVELS - 1](); // Re-get to access internal patterns if needed
                    if (bossTrack && bossTrack.hasOwnProperty("_events")) { // A way to check if it's a collection
                        // This part is tricky as direct access to patterns isn't clean.
                        // Better to ensure the loop function itself cleans up its patterns on stop/dispose.
                        // For now, the dummy loop for boss track means this might not be needed if patterns stop with transport.
                    }
                }
                currentMusicLoop = null; 
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            initGame();
            setupControls();
            if(ctx) { renderGame(); } 
        });
        
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            const gameContainer = document.getElementById('gameContainer');
            if (window.innerWidth <= 820) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = 800; 
                canvas.height = 500;
            }

            document.getElementById('livesDisplay').textContent = `Lives: ${lives}`; 
            document.getElementById('level').textContent = `Level: ${currentLevel + 1}/${TOTAL_LEVELS}`;
            resetLevel(); 
            gameState = STATE_SPLASH;
            showMessage("Quack out of Heck: Pip's Inferno", "start"); 
        }
        
        async function startGame() { 
            await ensureAudioContextAndTransportStarted();
            
            if (Tone.Transport.state === "started") { 
                Tone.Transport.stop();
                Tone.Transport.cancel(0);
            }
            stopMusic(); 

            currentLevel = 0; 
            startMusic(currentLevel); 

            gameState = STATE_PLAYING;
            lives = 3; 
            breadcrumbsCollected = 0; 
            document.getElementById('score').textContent = breadcrumbsCollected;
            document.getElementById('livesDisplay').textContent = `Lives: ${lives}`;
            document.getElementById('level').textContent = `Level: ${currentLevel + 1}/${TOTAL_LEVELS}`;
            hideMessage();
            resetLevel(); 
            if (animationFrame) cancelAnimationFrame(animationFrame); 
            gameLoop();
        }

        function createCollectibles(minX, minY, maxX, count, platformBased = false, thePlatforms = []) {
            const items = [];
            if (platformBased) {
                if (!thePlatforms || thePlatforms.length === 0) return items;
                for (let i = 0; i < count; i++) {
                    const platform = thePlatforms[Math.floor(Math.random() * thePlatforms.length)];
                    if (!platform) continue; 
                    const collectibleY = platform.y - 20 - (Math.random() * 10);
                    items.push({ x: platform.x + 20 + Math.random() * (platform.w - 40), y: collectibleY, w: 12, h: 12, collected: false });
                }
            } else { 
                for (let i = 0; i < count; i++) { items.push({ x: minX + Math.random() * (maxX - minX), y: minY - 50 - Math.random() * 150, w: 12, h: 12, collected: false }); }
            }
            return items;
        }
        
        function createLevels() { 
            // ... (Level definitions from previous version are kept here) ...
            return [
                // Level 0: Limbo 
                {
                    platforms: [ {x: 0, y: 400, w: 2500, h: 100, color: "#555"}, {x: 2600, y: 400, w: 2000, h: 100, color: "#555"}, 
                                 {x: 500, y: 320, w: 150, h: 25, color: "#666"}, {x: 900, y: 250, w: 120, h: 25, color: "#666"},
                                 {x: 1400, y: 300, w: 150, h: 25, color: "#666"}, {x: 3000, y: 280, w: 130, h: 25, color: "#666"}
                    ],
                    getCollectibles: function() { return createCollectibles(300, 350, 4000, 10, true, this.platforms); },
                    enemies: [ {type: 'normal', x: 900, y: 220, w: 30, h: 40, patrolRange: 30, speedMultiplier: 0.4, color: "#778899"}, 
                               {type: 'normal', x: 3100, y: 250, w: 30, h: 40, patrolRange: 40, speedMultiplier: 0.4, color: "#778899"}  
                    ],
                    finishLine: 4500, playerStart: {x: 50, y: 350}, pitType: 'none' 
                },
                // Level 1: Lust 
                {
                    platforms: [ {x: 0, y: 420, w: 1000, h: 80}, {x: 1150, y: 420, w: 1000, h: 80}, {x: 2300, y: 420, w: 2500, h: 80}, 
                                 {x: 300, y: 300, w: 100, h: 20}, {x: 600, y: 200, w: 80, h: 20, moving: {type: 'horizontal', startX: 550, endX: 750, speed: 3.5, pingPong: true}, direction: 'right'}, 
                                 {x: 1400, y: 350, w: 120, h: 20}, {x: 1700, y: 250, w: 100, h: 20},
                                 {x: 2500, y: 180, w: 80, h: 20}, {x: 2900, y: 300, w: 100, h: 20, moving: {type: 'vertical', startY: 180, endY: 350, speed: 2.2, pingPong: true}, direction: 'down'},
                                 {x: 3500, y: 220, w: 100, h: 20}
                    ],
                    getCollectibles: function() { return createCollectibles(200, 380, 4800, 15, true, this.platforms); },
                    enemies: [ {type: 'hopper', x: 300, y: 270, w: 35, h: 35, patrolRange:0, jumpForce: -13.5, jumpDelay: 70, erraticJump: true, color: "#FF69B4"}, 
                               {type: 'dasher', x: 1500, y: 390, w: 50, h: 20, patrolRange: 50, dashSpeed: 10, dashRange: 280, color: "#DC143C"}, 
                               {type: 'hopper', x: 2800, y: 390, w: 35, h: 35, patrolRange: 0, jumpForce: -13, jumpDelay: 80, erraticJump: true, color: "#FFC0CB"},
                               {type: 'dasher', x: 3500, y: 190, w: 50, h: 20, patrolRange: 0, dashSpeed: 9.5, dashRange: 200, color: "#DB7093"},
                    ],
                    finishLine: 5000, playerStart: {x: 50, y: 370}, pitType: 'fire'
                },
                // Level 2: Gluttony 
                 {
                    platforms: [ {x: 0, y: 400, w: 1000, h: 100, color:"#556B2F"}, {x: 1150, y: 400, w: 1500, h: 100, color:"#556B2F"}, {x: 2800, y: 400, w: 3000, h: 100, color:"#556B2F"}, 
                                 {x: 200, y: 200, w: 80, h: 20, color:"#6B8E23", slippery:true}, {x: 500, y: 300, w: 100, h: 20, moving: {type: 'vertical', startY: 250, endY: 350, speed: 0.7}, direction: 'up', color:"#6B8E23", slippery:true}, 
                                 {x: 1300, y: 250, w: 100, h: 20, color:"#6B8E23", slippery:true}, {x:1700, y:150, w:60, h:20, color:"#6B8E23", slippery:true}, 
                                 {x: 2900, y: 300, w: 120, h: 20, color:"#6B8E23", slippery:true}, {x:3300, y:200, w:100, h:20, moving: {type: 'horizontal', startX: 3200, endX: 3500, speed: 0.9}, direction: 'left', color:"#6B8E23", slippery:true},
                                 {x:3900, y:180, w:80, h:20, color:"#6B8E23", slippery:true}, {x:4300, y:280, w:100, h:20, color:"#6B8E23", slippery:true}
                    ],
                    getCollectibles: function() { return createCollectibles(100, 350, 5300, 18, true, this.platforms); },
                    enemies: [ {type: 'normal', x: 200, y: 170, w: 50, h: 40, patrolRange: 15, speedMultiplier: 0.3, color: "#3A5F0B"}, 
                               {type: 'normal', x: 700, y: 360, w: 55, h: 45, patrolRange: 25, speedMultiplier: 0.25, color: "#3A5F0B"},
                               {type: 'hopper', x: 1300, y: 220, w: 40, h: 50, patrolRange:0, jumpForce: -9, jumpDelay: 200, color:"#4F7942"}, 
                               {type: 'normal', x: 3000, y: 360, w: 50, h: 40, patrolRange: 30, speedMultiplier: 0.3, color: "#3A5F0B"},
                               {type: 'hopper', x: 4400, y: 360, w: 40, h: 50, patrolRange:0, jumpForce: -8, jumpDelay: 220, color:"#4F7942"},
                    ],
                    finishLine: 5600, playerStart: {x: 50, y: 350}, pitType: 'ice' 
                },
                // Level 3: Greed 
                {
                    platforms: [ {x:0, y:400, w:1000, h:100, color:"#B8860B"}, {x:1200, y:400, w:1000, h:100, color:"#B8860B"}, {x:2400, y:400, w:1000, h:100, color:"#B8860B"}, {x:3600, y:400, w:2000, h:100, color:"#B8860B"}, 
                                 {x:300,y:280,w:120,h:20, color:"#DAA520"}, {x:600,y:180,w:100,h:20, color:"#DAA520"},
                                 {x:1000,y:300,w:100,h:20, moving:{type:'horizontal',startX:950,endX:1150,speed:1.5}, direction:'right', color:"#CD853F"},
                                 {x:1500,y:250,w:120,h:20, color:"#DAA520"}, {x:1800,y:150,w:80,h:20, color:"#DAA520"},
                                 {x:2250,y:280,w:100,h:20, moving:{type:'vertical',startY:200,endY:350,speed:1.2}, direction:'up', color:"#CD853F"},
                                 {x:2700,y:200,w:120,h:20, color:"#DAA520"}, {x:3000,y:300,w:100,h:20, color:"#DAA520"},
                                 {x:4000,y:250,w:150,h:20, color:"#DAA520"}, {x:4500,y:180,w:100,h:20, color:"#DAA520"}
                    ],
                    getCollectibles: function(){ return createCollectibles(200,300,5300,25,true,this.platforms);}, 
                    enemies:[ {type:'dasher',x:300,y:250,w:40,h:30,patrolRange:30, dashSpeed:7, dashRange:100, color:"#8B4513"}, 
                               {type:'dasher',x:400,y:250,w:40,h:30,patrolRange:30, movingLeft:true, dashSpeed:7, dashRange:100, color:"#D2691E"}, 
                               {type:'normal',x:1500,y:370,w:55,h:25,patrolRange:60, color:"#BDB76B"}, 
                               {type:'hopper',x:2700,y:170,w:35,h:45,jumpForce:-14,jumpDelay:100, color:"#FFD700"}, 
                               {type:'dasher',x:4000,y:220,w:40,h:30,patrolRange:30, dashSpeed:7, dashRange:100, color:"#8B4513"}, {type:'dasher',x:4100,y:220,w:40,h:30,patrolRange:30, movingLeft:true, dashSpeed:7, dashRange:100, color:"#D2691E"},
                    ],
                    finishLine: 5800, playerStart:{x:50,y:350}, pitType: 'fire'
                },
                // Level 4: Wrath 
                {
                    platforms: [ {x:0,y:400,w:800,h:100, color:"#3A3A3A"}, {x:900,y:400,w:800,h:100, color:"#3A3A3A"}, {x:1800,y:400,w:800,h:100, color:"#3A3A3A"}, {x:2700,y:400,w:800,h:100, color:"#3A3A3A"}, {x:3600,y:400,w:2500,h:100, color:"#3A3A3A"}, 
                                 {x:200,y:300,w:80,h:20, color:"#4A4A4A"}, {x:400,y:200,w:80,h:20, color:"#4A4A4A"}, {x:600,y:300,w:80,h:20, color:"#4A4A4A"}, 
                                 {x:1000,y:250,w:100,h:20, color:"#4A4A4A"}, {x:1200,y:150,w:100,h:20, color:"#4A4A4A"}, {x:1400,y:250,w:100,h:20, color:"#4A4A4A"},
                                 {x:1900,y:300,w:80,h:20, moving:{type:'horizontal',startX:1850,endX:2050,speed:2.2}, direction:'right', color:"#5A5A5A"},
                                 {x:2200,y:200,w:80,h:20, color:"#4A4A4A"}, {x:2400,y:300,w:80,h:20, color:"#4A4A4A"},
                                 {x:3000,y:180,w:120,h:20, color:"#4A4A4A"}, {x:3300,y:280,w:120,h:20, color:"#4A4A4A"},
                                 {x:4000,y:200,w:100,h:20, color:"#4A4A4A"}, {x:4300,y:150,w:100,h:20, moving:{type:'vertical',startY:100,endY:250,speed:1.8}, direction:'down', color:"#5A5A5A"},
                                 {x:4800,y:300,w:150,h:20, color:"#4A4A4A"}
                    ],
                    getCollectibles: function(){ return createCollectibles(100,300,5800,28,true,this.platforms);},
                    enemies:[ {type:'dasher',x:200,y:270,w:45,h:25,patrolRange:10,dashSpeed:11,dashRange:160, color:"#FF4500"}, 
                               {type:'hopper',x:400,y:170,w:30,h:30,jumpForce:-15,jumpDelay:70, erraticJump:true, color:"#FF6347"}, 
                               {type:'dasher',x:1000,y:220,w:45,h:25,patrolRange:20,dashSpeed:11,dashRange:190, color:"#FF4500"},
                               {type:'hopper',x:1200,y:120,w:30,h:30,jumpForce:-16,jumpDelay:60, erraticJump:true, color:"#FF6347"},
                               {type:'normal',x:2000,y:370,w:45,h:30,patrolRange:100, speedMultiplier: 1.3, color:"#B22222"}, 
                               {type:'dasher',x:3000,y:150,w:50,h:25,patrolRange:30,dashSpeed:12,dashRange:220, color:"#FF4500"},
                               {type:'hopper',x:4000,y:170,w:35,h:35,jumpForce:-15,jumpDelay:75, erraticJump:true, color:"#FF6347"}, 
                               {type:'normal',x:5000,y:370,w:50,h:30,patrolRange:120, speedMultiplier: 1.4, color:"#B22222"}
                    ],
                    finishLine: 6000, playerStart:{x:50,y:350}, pitType: 'fire' 
                },
                // Level 5: Heresy (City of Dis) 
                {
                    platforms: [ {x:0,y:450,w:500,h:50, color:"#400000"}, {x:600,y:450,w:500,h:50, color:"#400000"}, {x:1250,y:450,w:500,h:50, color:"#400000"}, {x:1900,y:450,w:4000,h:50, color:"#400000"}, 
                                 {x:100,y:350,w:60,h:100, color:"#501010"}, {x:250,y:280,w:60,h:170, color:"#501010"}, {x:400,y:210,w:60,h:240, color:"#501010"}, 
                                 {x:700,y:350,w:60,h:100, color:"#501010"}, {x:850,y:280,w:60,h:170, color:"#501010"}, {x:1000,y:210,w:60,h:240, color:"#501010"},
                                 {x:1350,y:150,w:100,h:300, moving:{type:'vertical',startY:100,endY:300,speed:1.1}, direction:'up', color:"#602020"},
                                 {x:2000,y:350,w:100,h:100, color:"#501010"}, {x:2200,y:250,w:100,h:200, color:"#501010"}, {x:2400,y:150,w:100,h:300, color:"#501010"}, 
                                 {x:3000,y:300,w:120,h:150, color:"#501010"}, {x:3300,y:200,w:120,h:250, moving:{type:'horizontal',startX:3200,endX:3500,speed:1.9}, direction:'left', color:"#602020"},
                                 {x:3800,y:250,w:100,h:200, color:"#501010"}, {x:4200,y:180,w:100,h:270, color:"#501010"}
                    ],
                    getCollectibles: function(){ return createCollectibles(50,200,5500,30,true,this.platforms);},
                    enemies:[ {type:'normal',x:100,y:240,w:30,h:30,patrolRange:0, speedMultiplier:0.6, color:"#FF7F50"}, 
                               {type:'hopper',x:750,y:240,w:35,h:45,jumpForce:-13,jumpDelay:120, color:"#FF8C00"}, 
                               {type:'dasher',x:1500,y:420,w:50,h:25,patrolRange:40,dashSpeed:9.5,dashRange:180, color:COLORS.ENEMY_DASHER}, 
                               {type:'normal',x:2300,y:140,w:30,h:30,patrolRange:0, speedMultiplier:0.5, color:"#FF7F50"},
                               {type:'dasher',x:3900,y:140,w:55,h:25,patrolRange:30,dashSpeed:10.5,dashRange:150}
                    ],
                    finishLine: 6200, playerStart:{x:50,y:400}, pitType: 'fire'
                },
                // Level 6: Violence 
                {
                    platforms: [ {x:0,y:400,w:800,h:100, color:"#8B0000"}, 
                                 {x:900,y:300,w:150,h:20, moving:{type:'horizontal',startX:850,endX:1150,speed:1.3}, direction:'right', color:"#A52A2A"}, 
                                 {x:1300,y:400,w:800,h:100, color:"#2F4F4F"}, 
                                 {x:2200,y:250,w:120,h:20, color:"#556B2F"}, {x:2500,y:150,w:100,h:20, color:"#556B2F"}, 
                                 {x:2700,y:400,w:800,h:100, color:"#F4A460"}, 
                                 {x:3000,y:300,w:100,h:20, moving:{type:'vertical',startY:200,endY:350,speed:1.6}, direction:'down', color:"#CD853F"},
                                 {x:3600,y:400,w:3000,h:100} 
                    ],
                    getCollectibles: function(){ return createCollectibles(100,100,6400,32,true,this.platforms);},
                    enemies:[ {type:'dasher',x:950,y:270,w:50,h:25,patrolRange:0,dashSpeed:10,dashRange:200, color:"#B22222"}, 
                               {type:'hopper',x:1400,y:370,w:35,h:45,jumpForce:-14,jumpDelay:90, color:"#4B0082"}, 
                               {type:'normal',x:2200,y:220,w:40,h:30,patrolRange:50, color:"#8B4513"}, 
                               {type:'normal',x:2800,y:370,w:40,h:30,patrolRange:50, color:"#FF6347"}, 
                               {type:'dasher',x:3700,y:370,w:55,h:25,patrolRange:80,dashSpeed:11,dashRange:220},
                               {type:'hopper',x:4500,y:200,w:38,h:48,jumpForce:-15,jumpDelay:80}
                    ],
                    finishLine: 6600, playerStart:{x:50,y:350}, pitType: 'fire'
                },
                // Level 7: Fraud 
                {
                    platforms: [ {x:0,y:400,w:500,h:100}, 
                                 {x:600,y:300,w:50,h:20, moving:{type:'timed', duration:100, appearDuration:50, offset:0}},
                                 {x:750,y:200,w:50,h:20, moving:{type:'timed', duration:100, appearDuration:40, offset:50}},
                                 {x:900,y:300,w:50,h:20, moving:{type:'timed', duration:100, appearDuration:50, offset:20}}, 
                                 {x:1100,y:400,w:500,h:100}, 
                                 {x:1700,y:250,w:100,h:20, moving:{type:'horizontal',startX:1650,endX:1850,speed:2.8}, direction:'right'},
                                 {x:2000,y:150,w:80,h:20},
                                 {x:2200,y:400,w:500,h:100}, 
                                 {x:2800,y:300,w:50,h:20, moving:{type:'timed', duration:90, appearDuration:40, offset:30}},
                                 {x:2950,y:200,w:50,h:20, moving:{type:'timed', duration:90, appearDuration:35, offset:70}},
                                 {x:3100,y:300,w:50,h:20, moving:{type:'timed', duration:90, appearDuration:40, offset:40}},
                                 {x:3300,y:400,w:4000,h:100} 
                    ],
                    getCollectibles: function(){ return createCollectibles(50,100,7100,35,true,this.platforms);},
                    enemies:[ {type:'dasher',x:600,y:270,w:45,h:25,patrolRange:0,dashSpeed:10.5,dashRange:100, color:"#483D8B"}, 
                               {type:'hopper',x:1150,y:370,w:35,h:45,jumpForce:-14,jumpDelay:80, erraticJump:true, color:"#6A5ACD"}, 
                               {type:'normal',x:2250,y:370,w:40,h:30,patrolRange:100, speedMultiplier:0.8, color:"#7B68EE"}, 
                               {type:'dasher',x:3350,y:370,w:60,h:25,patrolRange:150,dashSpeed:11,dashRange:300},
                               {type:'hopper',x:4000,y:370,w:38,h:48,jumpForce:-15,jumpDelay:70, erraticJump:true},
                               {type:'normal',x:5000,y:370,w:45,h:30,patrolRange:200, speedMultiplier:0.9}, 
                               {type:'dasher',x:6000,y:370,w:60,h:25,patrolRange:200,dashSpeed:12,dashRange:350}
                    ],
                    finishLine: 7300, playerStart:{x:50,y:350}, pitType: 'fire'
                },
                // Level 8: Treachery 
                {
                    platforms: [ {x:0,y:400,w:400,h:100, slippery:true, color:"#ADD8E6"}, 
                                 {x:500,y:350,w:80,h:20, moving:{type:'vertical',startY:250,endY:380,speed:1.5}, direction:'down', slippery:true, color:"#B0E0E6"},
                                 {x:700,y:300,w:70,h:20, moving:{type:'horizontal',startX:650,endX:850,speed:1.2}, direction:'right', slippery:true, color:"#B0E0E6"},
                                 {x:950,y:350,w:80,h:20, moving:{type:'vertical',startY:250,endY:380,speed:1.5}, direction:'up', slippery:true, color:"#B0E0E6"},
                                 {x:1150,y:300,w:70,h:20, moving:{type:'horizontal',startX:1100,endX:1300,speed:1.2}, direction:'left', slippery:true, color:"#B0E0E6"},
                                 {x:1400,y:400,w:400,h:100, slippery:true, color:"#ADD8E6"}, 
                                 {x:1900,y:200,w:50,h:20, slippery:true, color:"#B0E0E6"}, {x:2000,y:150,w:50,h:20, slippery:true, color:"#B0E0E6"}, {x:2100,y:100,w:50,h:20, slippery:true, color:"#B0E0E6"}, 
                                 {x:2300,y:100,w:150,h:20, moving:{type:'horizontal',startX:2200,endX:2500,speed:1.8}, direction:'right', slippery:true, color:"#C0E0E6"}, 
                                 {x:2700,y:100,w:50,h:20, slippery:true, color:"#B0E0E6"}, {x:2800,y:150,w:50,h:20, slippery:true, color:"#B0E0E6"}, {x:2900,y:200,w:50,h:20, slippery:true, color:"#B0E0E6"}, 
                                 {x:3100,y:400,w:400,h:100, slippery:true, color:"#ADD8E6"}, 
                                 {x:3600,y:300,w:100,h:20, slippery:true, color:"#B0E0E6"}, {x:3800,y:200,w:100,h:20, slippery:true, color:"#B0E0E6"}, {x:4000,y:300,w:100,h:20, slippery:true, color:"#B0E0E6"},
                                 {x:4200,y:250,w:150,h:20, moving:{type:'vertical',startY:150,endY:350,speed:1.3}, direction:'down', slippery:true, color:"#C0E0E6"},
                                 {x:4500,y:180,w:100,h:20, slippery:true, color:"#B0E0E6"}, {x:4800,y:280,w:100,h:20, slippery:true, color:"#B0E0E6"},
                                 {x:5000,y:400,w:3000,h:100, slippery:true, color:"#ADD8E6"} 
                    ],
                    getCollectibles: function(){ return createCollectibles(100,50,7800,30,true,this.platforms);},
                    enemies:[ {type:'normal',x:500,y:320,w:30,h:30,patrolRange:10, speedMultiplier:0.2, color:"#AFEEEE"}, 
                               {type:'hopper',x:1450,y:370,w:30,h:30,jumpForce:-11,jumpDelay:180, color:"#AFEEEE"}, 
                               {type:'dasher',x:2300,y:70,w:50,h:20,patrolRange:0,dashSpeed:6,dashRange:120, color:"#98FB98"}, 
                               {type:'normal',x:3150,y:370,w:30,h:30,patrolRange:10, speedMultiplier:0.2, color:"#AFEEEE"},
                               {type:'hopper',x:5200,y:370,w:30,h:30,jumpForce:-12,jumpDelay:170, color:"#AFEEEE"}, 
                               {type:'dasher',x:5500,y:370,w:50,h:20,patrolRange:50,dashSpeed:7,dashRange:180, color:"#98FB98"}
                    ],
                    finishLine: 8000, playerStart:{x:50,y:350}, pitType: 'ice' 
                },
                // Level 9 (Kaiman's Throne - Judecca/Center of Hell) - BOSS FIGHT
                {
                    platforms: [ 
                        {x: 0, y: 450, w: 800, h: 50, color:"#100000"},  // Ground
                        {x: 100, y: 350, w: 120, h: 20, color:"#200000"}, // Left platform
                        {x: 300, y: 300, w: 120, h: 20, color:"#200000"}, // Middle-left platform
                        {x: 500, y: 250, w: 120, h: 20, color:"#200000"}, // Middle-right platform
                        {x: 650, y: 350, w: 120, h: 20, color:"#200000"}, // Right platform
                        {x: 400, y: 180, w: 150, h: 20, color:"#200000"}  // Top platform for boss fight
                    ], 
                    getCollectibles: function() { return []; }, 
                    enemies: [], 
                    isBossLevel: true, 
                    finishLine: 10000, 
                    playerStart: {x: 100, y: 380},
                    pitType: 'fire'
                }
            ];
        }
        
        function resetLevel() {
            const allLevels = createLevels();
            kaimanBoss = null; 
            document.getElementById('bossHealthBarContainer').style.display = 'none';

            if (currentLevel >= allLevels.length) { winGame(); return; }
            const level = allLevels[currentLevel];
            
            platforms = JSON.parse(JSON.stringify(level.platforms)); 
            collectibles = level.getCollectibles(); 
            enemies = JSON.parse(JSON.stringify(level.enemies)); 
            finishLine = level.finishLine; 
            
            enemies.forEach(enemy => { 
                enemy.originalX = enemy.x; enemy.originalY = enemy.y; 
                enemy.velY = 0; enemy.isGrounded = true; 
                enemy.jumpCooldown = enemy.jumpDelay || 120; 
                enemy.isDashing = false; enemy.dashCooldown = 0; 
                enemy.patrolDirection = 1; 
                if(enemy.patrolRange) enemy.movingLeft = Math.random() > 0.5;
            });
            platforms.forEach(p => {
                if (p.moving) { 
                    p.originalX = p.x; p.originalY = p.y; 
                    if (p.moving.type === 'vertical' && !p.direction) p.direction = p.moving.startY > p.moving.endY ? 'up' : 'down'; 
                    if (p.moving.type === 'horizontal' && !p.direction) p.direction = p.moving.startX > p.moving.endX ? 'left' : 'right';
                    if (p.moving.type === 'timed') { p.moving.timer = p.moving.offset || 0; p.visible = p.moving.timer < p.moving.appearDuration;}
                }
            });
            
            player = { 
                x: level.playerStart.x, y: level.playerStart.y, 
                w: 30, h: 35, 
                color: DUCK_PROGRESSION_COLORS[currentLevel] || COLORS.PLAYER_DEFAULT, 
                lastScaleMultiplier: 1, 
                invulnerabilityTimer: 0 
            };
            playerVelocity.x = 0; playerVelocity.y = 0;
            cameraOffset = 0; isJumping = false;
            // breadcrumbsCollected = 0; // Reset on full game start, not per life/level attempt
            document.getElementById('score').textContent = breadcrumbsCollected; 
            document.getElementById('level').textContent = `Level: ${currentLevel + 1}/${allLevels.length}`;
            document.getElementById('livesDisplay').textContent = `Lives: ${lives}`;


            if (level.isBossLevel) {
                const bossPlatform = platforms[0]; 
                kaimanBoss = {
                    x: canvas.width - 350, y: bossPlatform.y - 100, 
                    w: 250, h: 100, originalY: bossPlatform.y - 100,
                    headHitbox: { xoffset: 60, yoffset: 0, w: 130, h: 25 }, 
                    snoutOffset: 0, maxSnoutOffset: 70,
                    health: 10, maxHealth: 10,
                    state: 'patrolling', 
                    speed: 1.8, patrolDirection: -1,
                    lungeSpeed: 12, lungeDuration: 25, lungeTimer: 150, 
                    lungePrepTimer: 30, lungeLived: 0,
                    hitTimer: 0, hitDuration: 45, 
                    defeatTimer: 120
                };
                document.getElementById('bossHealthBarContainer').style.display = 'block';
                updateBossHealthBar();
            }
        }
        
        function setupControls() {
             window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') { togglePause(); return;}
                const msgVisible = document.getElementById('gameMessages').style.display === 'block';
                if (msgVisible && e.key !== 'Enter' && e.key !== ' ') return; 
                if (gameState !== STATE_PLAYING && gameState !== STATE_PAUSED) return;
                if (gameState === STATE_PAUSED && e.key !== 'r' && e.key !== 'R') return; 

                if (e.key === 'ArrowLeft' || e.key === 'a') playerInputs.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd') playerInputs.right = true;
                if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && !isJumping) { playerVelocity.y = PLAYER_JUMP_FORCE; isJumping = true; }
                if (e.key === 'r' || e.key === 'R') { 
                     if (gameState === STATE_GAMEOVER || gameState === STATE_WON) startGame(); 
                     else if (gameState === STATE_PLAYING || gameState === STATE_PAUSED) { 
                        lives = 3; 
                        breadcrumbsCollected = 0; 
                        document.getElementById('livesDisplay').textContent = `Lives: ${lives}`;
                        document.getElementById('score').textContent = breadcrumbsCollected;
                        resetLevel(); 
                        if(gameState === STATE_PAUSED) resumeGame(); 
                     }
                }
            });
            window.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') playerInputs.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd') playerInputs.right = false;
            });
            const dirButtons = document.querySelectorAll('.dir-btn');
            dirButtons.forEach(btn => {
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameState !== STATE_PLAYING && gameState !== STATE_PAUSED) return; if(gameState === STATE_PAUSED) return; switch(btn.id){ case 'left':playerInputs.left=true;break; case 'right':playerInputs.right=true;break; case 'up':if(!isJumping){playerVelocity.y=PLAYER_JUMP_FORCE;isJumping=true;}break;} }, {passive:false});
                btn.addEventListener('touchend', (e) => { e.preventDefault(); switch(btn.id){ case 'left':playerInputs.left=false;break; case 'right':playerInputs.right=false;break;} }, {passive:false});
            });
            document.getElementById('jumpBtn').addEventListener('touchstart', (e) => { e.preventDefault(); if(gameState!==STATE_PLAYING && gameState !== STATE_PAUSED)return; if(gameState === STATE_PAUSED) return; if(!isJumping){playerVelocity.y=PLAYER_JUMP_FORCE;isJumping=true;} }, {passive:false});
            
            const muteButton = document.getElementById('muteButton');
            muteButton.addEventListener('click', () => {
                if (!musicInitialized && Tone.context.state !== 'running') { 
                    Tone.start().then(initializeAudio);
                }
                isMuted = !isMuted;
                Tone.Destination.mute = isMuted;
                muteButton.textContent = isMuted ? "Unmute üîá" : "Mute üîä";
            });
            document.getElementById('restartButton').addEventListener('click', handleMessageButtonClick);
        }

        async function ensureAudioContextAndTransportStarted() {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }
            if (!musicInitialized) { 
                initializeAudio();
            }
            if (Tone.Transport.state !== "started") {
                Tone.Transport.start(Tone.now() + 0.1); 
            }
        }

        async function handleMessageButtonClick() { 
            const button = document.getElementById('restartButton');
            const actionType = button.getAttribute('data-action-type');
            
            await ensureAudioContextAndTransportStarted();
            
            if (actionType === "start" || actionType === "retry") {
                proceedWithAction(actionType); // startGame will handle music
            } else if (actionType === "resume" || actionType === "continue_level") {
                startMusic(currentLevel); 
                proceedWithAction(actionType);
            } else {
                 proceedWithAction(actionType); 
            }
        }

        function proceedWithAction(actionType) {
            hideMessage(); 
            if (actionType === "continue_level") {
                gameState = STATE_PLAYING;
                if (animationFrame) cancelAnimationFrame(animationFrame);
                gameLoop();
            } else if (actionType === "resume") { 
                if (gameState === STATE_PAUSED || (gameState === STATE_SPLASH && document.getElementById('messageText').textContent === "Game Paused")) {
                    resumeGame();
                } else { 
                    startGame(); 
                }
            } else { 
                startGame();
            }
        }
        
        function resumeGame() {
            if (gameState === STATE_PAUSED || (gameState === STATE_SPLASH && document.getElementById('messageText').textContent === "Game Paused") ) { 
                gameState = STATE_PLAYING;
                hideMessage(); 
                if (animationFrame) cancelAnimationFrame(animationFrame); 
                gameLoop();
            }
        }

        function togglePause() {
            if (gameState === STATE_PLAYING) {
                gameState = STATE_PAUSED;
                if (animationFrame) cancelAnimationFrame(animationFrame); 
                // Don't stop music on pause
                showMessage("Game Paused", "resume");
            } else if (gameState === STATE_PAUSED) {
                resumeGame();
            }
        }
        
        function updatePlatforms() { 
            platforms.forEach(p => {
                if (p.moving) {
                    const moveSpeed = p.moving.speed || 1;
                    if (p.moving.type === 'vertical') {
                        if (p.direction === 'down') { p.y += moveSpeed; if (p.y >= p.moving.endY) { p.y = p.moving.endY; p.direction = 'up'; } }
                        else { p.y -= moveSpeed; if (p.y <= p.moving.startY) { p.y = p.moving.startY; p.direction = 'down'; } }
                    } else if (p.moving.type === 'horizontal') {
                        if (p.direction === 'right') { p.x += moveSpeed; if (p.x >= p.moving.endX) { p.x = p.moving.endX; p.direction = 'left'; } }
                        else { p.x -= moveSpeed; if (p.x <= p.moving.startX) { p.x = p.moving.startX; p.direction = 'right'; } }
                    } else if (p.moving.type === 'timed') {
                        p.moving.timer = (p.moving.timer + 1) % p.moving.duration;
                        p.visible = p.moving.timer < p.moving.appearDuration;
                    }
                }
            });
        }
        
        function updateGame() {
            if (gameState !== STATE_PLAYING) return;

            if (player.invulnerabilityTimer > 0) {
                player.invulnerabilityTimer--;
            }

            updatePlatforms(); 
            const farMountainSpeed = 0.005 + (currentLevel * 0.0035); 
            const nearMountainSpeed = 0.01 + (currentLevel * 0.007);  
            bgOffsetX = (bgOffsetX + playerVelocity.x * farMountainSpeed); 
            bgOffsetX2 = (bgOffsetX2 + playerVelocity.x * nearMountainSpeed);

            updateEnemies();
            if (kaimanBoss && kaimanBoss.state !== 'defeated') updateBoss();
            
            playerVelocity.y += GRAVITY;
            let currentFriction = PLAYER_DECEL;
            let currentAccel = PLAYER_ACCEL;
            platforms.forEach(p => {
                if (p.slippery && collisionDetected({x: player.x, y: player.y + 1, w: player.w, h: player.h}, p)) { 
                    currentFriction = 0.05; 
                    currentAccel = 0.08; 
                }
            });


            if (playerInputs.left) playerVelocity.x = Math.max(-MAX_SPEED, playerVelocity.x - currentAccel);
            else if (playerInputs.right) playerVelocity.x = Math.min(MAX_SPEED, playerVelocity.x + currentAccel);
            else {
                if (playerVelocity.x > 0) playerVelocity.x = Math.max(0, playerVelocity.x - currentFriction);
                else if (playerVelocity.x < 0) playerVelocity.x = Math.min(0, playerVelocity.x + currentFriction);
            }
            
            const prevPlayerY = player.y;

            player.x += playerVelocity.x;
            for (const p of platforms) { 
                if (p.visible === false) continue; 
                if (collisionDetected(player, p)) { 
                    if (playerVelocity.x > 0) player.x = p.x - player.w; 
                    else if (playerVelocity.x < 0) player.x = p.x + p.w; 
                    playerVelocity.x = 0; 
                } 
            }
            
            player.y += playerVelocity.y;
            let isOnGround = false; 
            for (const p of platforms) { 
                if (p.visible === false) continue;
                if (collisionDetected(player, p)) {
                    if (playerVelocity.y > 0) { player.y = p.y - player.h; isOnGround = true; isJumping = false; playerVelocity.y = 0; }
                    else if (playerVelocity.y < 0 && prevPlayerY >= p.y + p.h) { player.y = p.y + p.h; playerVelocity.y = 0.1; } 
                    
                    if (p.moving && isOnGround && Math.abs((player.y + player.h) - p.y) < 1.5) { 
                        let dx = 0, dy = 0;
                        if (p.moving.type === 'vertical') dy = (p.direction === 'down' ? p.moving.speed : -p.moving.speed);
                        if (p.moving.type === 'horizontal') dx = (p.direction === 'right' ? p.moving.speed : -p.moving.speed);
                        player.x += dx; player.y += dy;
                    }
                }
            }
            
            if (player.x < 0) { player.x = 0; if (playerVelocity.x < 0) playerVelocity.x = 0; }

            for (let i = collectibles.length - 1; i >= 0; i--) { 
                if (!collectibles[i].collected && collisionDetected(player, collectibles[i])) { 
                    collectibles[i].collected = true; 
                    breadcrumbsCollected++; 
                    document.getElementById('score').textContent = breadcrumbsCollected;
                    playCrumbCollectSound(); 
                } 
            }
            
            if (player.invulnerabilityTimer <= 0) { 
                for (let i = enemies.length - 1; i >= 0; i--) { 
                    const e = enemies[i];
                    if (collisionDetected(player, e)) {
                        if (playerVelocity.y > 0.1 && (player.y + player.h - playerVelocity.y * 0.7) <= e.y + e.h * 0.2 ) { 
                            enemies.splice(i, 1); playerVelocity.y = PLAYER_JUMP_FORCE * 0.65; isJumping = true;
                            playEnemyDefeatSound(); 
                        } else { 
                            handlePlayerDamage();
                            return; 
                        }
                    }
                }
            }
            
            if (kaimanBoss && kaimanBoss.state !== 'defeated' && kaimanBoss.state !== 'hit' && kaimanBoss.hitTimer <=0 && player.invulnerabilityTimer <= 0) {
                const actualBossHead = { x: kaimanBoss.x + kaimanBoss.headHitbox.xoffset, y: kaimanBoss.y + kaimanBoss.headHitbox.yoffset, w: kaimanBoss.headHitbox.w, h: kaimanBoss.headHitbox.h };
                const bossBody = {x: kaimanBoss.x, y: kaimanBoss.y + kaimanBoss.headHitbox.h, w: kaimanBoss.w, h: kaimanBoss.h - kaimanBoss.headHitbox.h}; 

                if (collisionDetected(player, actualBossHead) && playerVelocity.y > 0.1 && (player.y + player.h - playerVelocity.y * 0.7) <= actualBossHead.y + actualBossHead.h * 0.3 ) { 
                    if(kaimanBoss.health > 0 && kaimanBoss.hitTimer <= 0) {
                        kaimanBoss.health--; updateBossHealthBar();
                        kaimanBoss.state = 'hit'; kaimanBoss.hitTimer = kaimanBoss.hitDuration;
                        playerVelocity.y = PLAYER_JUMP_FORCE * 0.75; isJumping = true;
                        playEnemyDefeatSound(); 
                        if (kaimanBoss.health <= 0) { kaimanBoss.state = 'defeated'; kaimanBoss.defeatTimer = 120; } 
                    }
                } else if (collisionDetected(player, bossBody) || (collisionDetected(player, actualBossHead) && !(playerVelocity.y > 0.1))) { 
                    handlePlayerDamage();
                    return; 
                }
            }
            
            const levelEndX = finishLine; 
            if (player.x + player.w / 2 > levelEndX && !(currentLevel === TOTAL_LEVELS - 1 && kaimanBoss && kaimanBoss.health > 0)) { 
                if (currentLevel < TOTAL_LEVELS - 1) nextLevel(); else winGame(); return; 
            }
            
            const levelTotalWidth = kaimanBoss ? Math.max(platforms[0].x + platforms[0].w, kaimanBoss.x + kaimanBoss.w + 100) : Math.max(...platforms.map(p => p.x + p.w), finishLine + 100);
            cameraOffset = player.x - canvas.width / 2.5; 
            cameraOffset = Math.max(0, cameraOffset); 
            cameraOffset = Math.min(cameraOffset, Math.max(0, levelTotalWidth - canvas.width)); 

            if (player.y > canvas.height + player.h * 1.2) { 
                lives--;
                document.getElementById('livesDisplay').textContent = `Lives: ${lives}`;
                if (lives <= 0) {
                    playDyingQuack(); 
                    gameOver();
                } else {
                    playHurtQuack(); 
                    breadcrumbsCollected = 0; 
                    document.getElementById('score').textContent = breadcrumbsCollected;
                    resetLevel(); 
                }
            }
        }

        function handlePlayerDamage() {
            if (player.invulnerabilityTimer > 0) return; 

            if (breadcrumbsCollected > 0) {
                breadcrumbsCollected = 0;
                document.getElementById('score').textContent = breadcrumbsCollected;
                player.invulnerabilityTimer = PLAYER_INVULNERABILITY_DURATION;
                playHurtQuack();
                playerVelocity.y = PLAYER_JUMP_FORCE * 0.3; 
                isJumping = true; 
                playerVelocity.x = (player.x < (cameraOffset + canvas.width / 2) ? 3 : -3); 
            } else {
                lives--;
                document.getElementById('livesDisplay').textContent = `Lives: ${lives}`;
                if (lives <= 0) {
                    playDyingQuack();
                    gameOver();
                } else {
                    playHurtQuack();
                    resetLevel(); 
                }
            }
        }


        function updateEnemies() {
            enemies.forEach(e => {
                const enemySpeed = (e.speedMultiplier || 1.0) * (1.0 + (currentLevel * 0.08)); 
                if (e.type === 'hopper') {
                    if (e.isGrounded) {
                        e.jumpCooldown--;
                        if (e.jumpCooldown <= 0) {
                            e.isGrounded = false; e.velY = e.jumpForce || -12;
                            if (e.erraticJump || (Math.abs(player.x - e.x) < 250 && Math.abs(player.y - e.y) < 100)) e.velX = (player.x > e.x ? 1 : -1) * (Math.random() * 1.5 + 1);
                            else e.velX = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 0.8 + 0.4);
                            e.jumpCooldown = (e.jumpDelay || 120) + Math.random() * 40;
                        }
                    } else {
                        e.velY += GRAVITY * 0.7; e.y += e.velY; e.x += e.velX || 0;
                        let landedOnPlatform = false;
                        platforms.forEach(p => { if(p.visible !== false && collisionDetected(e, p) && e.velY > 0 && e.y + e.h >= p.y && e.y + e.h - e.velY <= p.y + 1 ) { e.y = p.y - e.h; e.isGrounded = true; e.velY = 0; e.velX = 0; e.originalY = e.y; landedOnPlatform = true;} });
                        if (!landedOnPlatform && e.y >= e.originalY && e.originalY > 0) { e.y = e.originalY; e.isGrounded = true; e.velY = 0; e.velX = 0; } 
                        if (e.x < cameraOffset - e.w * 2 || e.x > cameraOffset + canvas.width + e.w * 2) e.velX = 0; 
                    }
                } else if (e.type === 'dasher') {
                    e.dashCooldown = Math.max(0, e.dashCooldown -1);
                    if (!e.isDashing && e.dashCooldown <= 0 && Math.abs(player.x - e.x) < (e.dashRange || 200) && Math.abs(player.y - (e.y + e.h/2)) < e.h * 1.5) {
                        e.isDashing = true; e.dashDirection = (player.x > e.x ? 1 : -1); e.dashTimer = 20; 
                    }
                    if (e.isDashing) {
                        e.x += e.dashDirection * (e.dashSpeed || 8); e.dashTimer--;
                        if (e.dashTimer <= 0) { e.isDashing = false; e.dashCooldown = 90; } 
                    } else if (e.patrolRange) { 
                        const speed = enemySpeed * (e.speedMultiplier || 0.7);
                        if (e.movingLeft) { e.x -= speed; if (e.x <= e.originalX - e.patrolRange) {e.x = e.originalX - e.patrolRange; e.movingLeft = false;} }
                        else { e.x += speed; if (e.x >= e.originalX + e.patrolRange) {e.x = e.originalX + e.patrolRange; e.movingLeft = true;} }
                    }
                } else { // Normal enemy
                    if (e.patrolRange) {
                        const speed = enemySpeed; 
                        if (e.movingLeft) { e.x -= speed; if (e.x <= e.originalX - e.patrolRange) {e.x = e.originalX - e.patrolRange; e.movingLeft = false;} }
                        else { e.x += speed; if (e.x >= e.originalX + e.patrolRange) {e.x = e.originalX + e.patrolRange; e.movingLeft = true;} }
                    }
                }
            });
        }

        function updateBoss() {
            if (!kaimanBoss || kaimanBoss.state === 'defeated') return;
            if (kaimanBoss.hitTimer > 0) kaimanBoss.hitTimer--;

            const bossPlatform = platforms[0]; 

            switch (kaimanBoss.state) {
                case 'patrolling':
                    kaimanBoss.x += kaimanBoss.speed * kaimanBoss.patrolDirection;
                    if (kaimanBoss.x < bossPlatform.x) { kaimanBoss.x = bossPlatform.x; kaimanBoss.patrolDirection = 1; }
                    if (kaimanBoss.x + kaimanBoss.w > bossPlatform.x + bossPlatform.w) { kaimanBoss.x = bossPlatform.x + bossPlatform.w - kaimanBoss.w; kaimanBoss.patrolDirection = -1; }
                    kaimanBoss.lungeTimer--;
                    if (kaimanBoss.lungeTimer <= 0) { kaimanBoss.state = 'preLunge'; kaimanBoss.lungePrepTimer = 30; kaimanBoss.snoutOffset = 0; }
                    break;
                case 'preLunge':
                    kaimanBoss.lungePrepTimer--;
                    if (kaimanBoss.lungePrepTimer <= 0) {
                        kaimanBoss.state = 'lunging'; kaimanBoss.lungeLived = kaimanBoss.lungeDuration;
                        if (player.x < kaimanBoss.x + kaimanBoss.w / 2) kaimanBoss.patrolDirection = -1; else kaimanBoss.patrolDirection = 1;
                    }
                    break;
                case 'lunging':
                    kaimanBoss.x += kaimanBoss.lungeSpeed * kaimanBoss.patrolDirection;
                    kaimanBoss.snoutOffset = Math.min(kaimanBoss.maxSnoutOffset, kaimanBoss.snoutOffset + 6); 
                    kaimanBoss.lungeLived--;
                    if (kaimanBoss.x < bossPlatform.x) kaimanBoss.x = bossPlatform.x;
                    if (kaimanBoss.x + kaimanBoss.w + kaimanBoss.snoutOffset > bossPlatform.x + bossPlatform.w) kaimanBoss.x = bossPlatform.x + bossPlatform.w - kaimanBoss.w - kaimanBoss.snoutOffset;
                    if (kaimanBoss.lungeLived <= 0) { kaimanBoss.state = 'patrolling'; kaimanBoss.lungeTimer = 100 + Math.random() * 50; kaimanBoss.snoutOffset = 0; }
                    break;
                case 'hit':
                    if (kaimanBoss.hitTimer <= 0) { kaimanBoss.state = 'patrolling'; }
                    break;
                case 'defeated': 
                    kaimanBoss.y += 1.5; kaimanBoss.w = Math.max(10, kaimanBoss.w - 1.5); kaimanBoss.h = Math.max(5, kaimanBoss.h - 0.75);
                    kaimanBoss.defeatTimer--;
                    if (kaimanBoss.defeatTimer <= 0) { winGame(); } 
                    break;
            }
        }
        function updateBossHealthBar() {
            if (kaimanBoss) {
                const healthPercentage = Math.max(0, (kaimanBoss.health / kaimanBoss.maxHealth) * 100);
                document.getElementById('bossHealthBar').style.width = healthPercentage + '%';
            }
        }
        
        function renderGame() {
            ctx.fillStyle = COLORS.SKY[Math.floor(Date.now()/25000) % COLORS.SKY.length]; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(-cameraOffset, 0); 
            drawFloatingMountains(); 
            drawHazardPits(); 

            platforms.forEach(p => { 
                if (p.visible === false) return; 
                ctx.fillStyle = p.color || COLORS.PLATFORM; 
                ctx.fillRect(p.x, p.y, p.w, p.h); 
            });
            
            if (!(currentLevel === TOTAL_LEVELS - 1 && kaimanBoss && kaimanBoss.health > 0)) { 
                ctx.fillStyle = COLORS.FINISH_LINE; ctx.fillRect(finishLine - 10, 0, 20, canvas.height); 
            }
            
            collectibles.forEach(c => { if (!c.collected) { ctx.fillStyle = COLORS.COLLECTIBLE; ctx.beginPath(); ctx.arc(c.x + c.w/2, c.y + c.h/2, c.w/1.8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.beginPath(); ctx.arc(c.x + c.w/2 - 2, c.y + c.h/2 - 2, c.w/3, 0, Math.PI * 2); ctx.fill(); }});
            
            enemies.forEach(e => {
                let enemyColor = e.color || COLORS.ENEMY_NORMAL; 
                if (e.type === 'hopper') enemyColor = e.color || COLORS.ENEMY_HOPPER;
                else if (e.type === 'dasher') enemyColor = e.color || COLORS.ENEMY_DASHER;
                
                ctx.fillStyle = enemyColor; 
                ctx.fillRect(e.x, e.y, e.w, e.h); 

                // Simplified "eye" or detail based on type
                if (e.type === 'hopper') {ctx.fillStyle = '#2E7D32'; ctx.fillRect(e.x+e.w*0.2, e.y-e.h*0.2, e.w*0.6, e.h*0.4); } 
                else if (e.type === 'dasher') {ctx.fillStyle = '#BF360C'; ctx.fillRect(e.x + (e.dashDirection > 0 ? e.w*0.7 : e.w*0.1), e.y+e.h*0.3, e.w*0.2, e.h*0.4); } 
                else {ctx.fillStyle = '#A02020'; ctx.fillRect(e.x + e.w * (e.movingLeft ? 0.25 : 0.55), e.y + e.h * 0.25, e.w*0.2, e.h*0.2);}
            });
            
            if (kaimanBoss) drawBoss(); 
            if (player) drawPlayer(); 
            ctx.restore(); 
        }

        function drawHazardPits() {
            const currentLevelData = createLevels()[currentLevel];
            if (!currentLevelData || currentLevelData.pitType === 'none') return;

            const pitBottomY = canvas.height - 10; 
            const particleSize = 10;
            let pitColor1 = COLORS.FIRE_PIT_PRIMARY;
            let pitColor2 = COLORS.FIRE_PIT_SECONDARY;

            if (currentLevelData.pitType === 'ice') {
                pitColor1 = COLORS.ICE_PIT_PRIMARY;
                pitColor2 = COLORS.ICE_PIT_SECONDARY;
            }
            
            ctx.fillStyle = pitColor1;
            ctx.fillRect(cameraOffset, pitBottomY - 40, canvas.width, 60); 

            for (let i = 0; i < canvas.width / particleSize; i++) { 
                if (Math.random() > 0.2) { 
                    ctx.fillStyle = Math.random() > 0.5 ? pitColor1 : pitColor2;
                    const x = cameraOffset + Math.random() * canvas.width;
                    const y = pitBottomY - 40 + Math.random() * 40 - (Math.random() * 20); 
                    const size = particleSize * (0.4 + Math.random() * 0.9);
                    ctx.fillRect(x, y, size, size);
                }
            }
            if (currentLevel === TOTAL_LEVELS - 1 && platforms.length > 0) { 
                const bossPlatform = platforms[0];
                ctx.fillStyle = COLORS.FIRE_PIT_PRIMARY;
                ctx.fillRect(cameraOffset, bossPlatform.y + bossPlatform.h - 10, bossPlatform.x - cameraOffset, 40);
                ctx.fillRect(bossPlatform.x + bossPlatform.w, bossPlatform.y + bossPlatform.h - 10, (cameraOffset + canvas.width) - (bossPlatform.x + bossPlatform.w), 40);
            }
        }


        function drawBoss() {
            if (!kaimanBoss) return;
            let bodyColor = COLORS.BOSS_BODY;
            if (kaimanBoss.state === 'hit' && Math.floor(kaimanBoss.hitTimer / 4) % 2 === 0) { bodyColor = COLORS.BOSS_HIT; }
            if (kaimanBoss.state === 'defeated') bodyColor = `rgba(46,139,87, ${Math.max(0, kaimanBoss.defeatTimer/120)})`; 


            const actualSnoutX = kaimanBoss.patrolDirection === 1 ? kaimanBoss.x + kaimanBoss.w : kaimanBoss.x - kaimanBoss.snoutOffset;
            const snoutWidth = kaimanBoss.w * 0.4 + kaimanBoss.snoutOffset;

            ctx.fillStyle = kaimanBoss.state === 'hit' ? COLORS.BOSS_HIT : COLORS.BOSS_SNOUT;
            ctx.fillRect(actualSnoutX, kaimanBoss.y + kaimanBoss.h * 0.25, snoutWidth, kaimanBoss.h * 0.5);
            
            ctx.fillStyle = bodyColor;
            ctx.fillRect(kaimanBoss.x, kaimanBoss.y, kaimanBoss.w, kaimanBoss.h);

            ctx.fillStyle = kaimanBoss.state === 'hit' ? '#FFA07A' : '#3CB371'; 
            ctx.fillRect(kaimanBoss.x + kaimanBoss.headHitbox.xoffset, kaimanBoss.y + kaimanBoss.headHitbox.yoffset, kaimanBoss.headHitbox.w, kaimanBoss.headHitbox.h);
        
            const eyeX = kaimanBoss.patrolDirection === 1 ? kaimanBoss.x + kaimanBoss.w * 0.7 : kaimanBoss.x + kaimanBoss.w * 0.3 - 15;
            ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(eyeX, kaimanBoss.y + 25, 12, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(eyeX + (kaimanBoss.patrolDirection * 2), kaimanBoss.y + 25, 6, 0, Math.PI*2); ctx.fill();
        }
        
        function drawPlayer() { 
            ctx.save(); 
            if (player.invulnerabilityTimer > 0 && Math.floor(player.invulnerabilityTimer / 5) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            } else {
                ctx.globalAlpha = 1.0;
            }

            ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
            let scaleX = player.lastScaleMultiplier || 1;
            if (playerVelocity.x < -0.05) scaleX = -1; else if (playerVelocity.x > 0.05) scaleX = 1;
            player.lastScaleMultiplier = scaleX;
            ctx.scale(scaleX, 1);
            ctx.fillStyle = player.color; ctx.beginPath(); ctx.ellipse(0,0,player.w/2,player.h/2,0,0,Math.PI*2); ctx.fill(); 
            const headX = player.w/2.8; const headY = -player.h/2.8; 
            ctx.beginPath(); ctx.ellipse(headX,headY,player.w/3.2,player.h/3.2,0,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle = '#FF8F00'; ctx.beginPath(); ctx.ellipse(headX+player.w/3,headY,player.w/4,player.h/8,0,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(headX+player.w/4,headY-player.h/10,3.2,0,Math.PI*2); ctx.fill(); 
            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(headX+player.w/4+0.8,headY-player.h/10-0.8,1.1,0,Math.PI*2); ctx.fill(); 
            const wingAngle = isJumping ? Math.PI/2.5 : Math.PI/4; const wingYOff = isJumping ? player.h/11 : player.h/8;
            ctx.fillStyle = '#D4AC0D'; ctx.beginPath(); ctx.ellipse(-player.w/10,wingYOff,player.w/3.5,player.h/3.5,wingAngle,0,Math.PI*2); ctx.fill(); 
            ctx.restore(); 
        }
        
        function drawFloatingMountains() { 
            if (currentLevel === 0) return; 

            const groundLevelY = canvas.height * 0.88; 
            for (let i = -2; i <= Math.ceil(canvas.width / 170) + 2; i++) { const mBaseX = i * 170 - (bgOffsetX % 170); drawSingleMountain(mBaseX, groundLevelY, 190, 150, 2, COLORS.FAR_MOUNTAINS); }
            for (let i = -2; i <= Math.ceil(canvas.width / 90) + 2; i++) { const mBaseX = i * 90 - (bgOffsetX2 % 90); drawSingleMountain(mBaseX, groundLevelY, 100, 100, 1, COLORS.NEAR_MOUNTAINS); }
        }
        function drawSingleMountain(baseX, baseYOnScreen, width, maxHeight, numPeaks, color) { 
            ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(baseX, baseYOnScreen + 70); 
            let currentX = baseX;
            for (let i = 0; i < numPeaks; i++) {
                const peakH = maxHeight*(0.55+Math.random()*0.45); const peakW = (width/numPeaks)*(0.65+Math.random()*0.7); 
                const peakTX = currentX + peakW/2 + (Math.random()-0.5)*peakW*0.1;
                ctx.lineTo(peakTX, baseYOnScreen - peakH); currentX += peakW; ctx.lineTo(currentX, baseYOnScreen); 
            }
            ctx.lineTo(baseX + width + 70, baseYOnScreen + 70); ctx.lineTo(baseX, baseYOnScreen + 70); 
            ctx.closePath(); ctx.fill();
        }
        function collisionDetected(r1,r2){return r1.x<r2.x+r2.w && r1.x+r1.w>r2.x && r1.y<r2.y+r2.h && r1.y+r1.h>r2.y;}
        
        function gameOver() { gameState = STATE_GAMEOVER; if(animationFrame)cancelAnimationFrame(animationFrame); stopMusic(); Tone.Transport.stop(); Tone.Transport.cancel(0); showMessage("PIP IS STUCK IN HECK FOREVER!", "retry"); }
        function winGame() { gameState = STATE_WON; if(animationFrame)cancelAnimationFrame(animationFrame); stopMusic(); Tone.Transport.stop(); Tone.Transport.cancel(0); playVictorySound(); showMessage("PIP QUACKED OUT OF HECK!", "retry"); }
        
        function nextLevel() {
            currentLevel++;
            if (currentLevel < TOTAL_LEVELS) {
                if (animationFrame) cancelAnimationFrame(animationFrame);
                gameState = STATE_SPLASH; 
                resetLevel(); 
                playVictorySound(); 
                // Music for the new level will be started by handleMessageButtonClick -> proceedWithAction -> startMusic
                showMessage(`Circle ${currentLevel + 1}: Deeper into Heck...`, "continue_level");
            } else { 
                winGame(); 
            }
        }
        
        function showMessage(text, buttonType = "retry") {
            const messageBox = document.getElementById('gameMessages');
            document.getElementById('messageText').textContent = text;
            const button = document.getElementById('restartButton');
            
            button.setAttribute('data-action-type', buttonType); 

            if (buttonType === "continue_level") button.textContent = "Proceed...";
            else if (buttonType === "resume") button.textContent = "Resume Game";
            else if (buttonType === "retry") button.textContent = "Try Again, Pip?";
            else if (buttonType === "start") button.textContent = "Begin the Descent";
            else button.textContent = "OK";
            
            messageBox.style.display = "block"; button.style.display = "block"; 
            if (gameState !== STATE_PAUSED && gameState !== STATE_PLAYING ) { 
                 if (animationFrame) cancelAnimationFrame(animationFrame);
            }
        }
        
        function hideMessage() { document.getElementById('gameMessages').style.display = "none"; }
        
        function gameLoop() {
            if (gameState === STATE_PLAYING) { updateGame(); renderGame(); }
            else { renderGame(); return; } 
            animationFrame = requestAnimationFrame(gameLoop);
        }

        window.addEventListener('resize', () => { 
            const gameContainer = document.getElementById('gameContainer');
            let newWidth, newHeight;
            if (window.innerWidth <= 820) { 
                newWidth = window.innerWidth;
                newHeight = window.innerHeight;
            } else { 
                newWidth = 800; 
                newHeight = 500;
            }
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            if (gameState !== STATE_PLAYING && gameState !== STATE_PAUSED) { renderGame(); }
        });

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>
